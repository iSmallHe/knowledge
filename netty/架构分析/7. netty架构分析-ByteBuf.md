# ByteBuf与ByteBuffer

`ByteBuf`是`netty`用来处理字节数据的缓冲接口，较之`ByteBuffer`，拥有更便捷的方法来处理数据读写

## ByteBuffer

在学习`ByteBuf`之前，我们先要熟悉下JDK自带的缓冲器`ByteBuffer`

### 属性

1. `mark`：用于标记，使用`mark()`方法时，可将当前`position`赋值给`mark`；通过`markValue()`获取值。
2. `position`：指向当前读/写的下标；`position()`获取当前下标
3. `limit`：限制读写；`limit()`方法获取值
4. `capacity`：容器总容量；`capacity()`方法获取值


### 常用方法

以`HeapByteBuffer`为示例：

1. `flip`：切换读写
```java
    public final Buffer flip() {
        limit = position;
        position = 0;
        mark = -1;
        return this;
    }
```

2. `clear`：清空数据
```java
    public final Buffer clear() {
        position = 0;
        limit = capacity;
        mark = -1;
        return this;
    }
```

3. `reset`：回到标记点
```java
    public final Buffer reset() {
        int m = mark;
        if (m < 0)
            throw new InvalidMarkException();
        position = m;
        return this;
    }
```

4. `rewind`：重置`position`，`mark`值
```java
    public final Buffer rewind() {
        position = 0;
        mark = -1;
        return this;
    }
```

5. `remaining`：剩余可操作空间
```java
    public final int remaining() {
        int rem = limit - position;
        return rem > 0 ? rem : 0;
    }
```

6. `nextGetIndex`：下一个读的下标
```java
    final int nextGetIndex() {                          // package-private
        int p = position;
        if (p >= limit)
            throw new BufferUnderflowException();
        position = p + 1;
        return p;
    }
```

7. `nextPutIndex`：下一个写的下标
```java
    final int nextPutIndex() {                          // package-private
        int p = position;
        if (p >= limit)
            throw new BufferOverflowException();
        position = p + 1;
        return p;
    }
```

8. `slice`：切片；此时会创建一个新的ByteBuffer，两者共享同一段数据，但是slice会重置部分参数，并修改offset = 当前下标 + 原offset；

```java
    public ByteBuffer slice() {
        int pos = this.position();
        int lim = this.limit();
        int rem = (pos <= lim ? lim - pos : 0);
        return new HeapByteBuffer(hb,
                                        -1,
                                        0,
                                        rem,
                                        rem,
                                        pos + offset);
    }
```

9. `duplicate`：复制；此时会创建一个新的ByteBuffer，两者数据完全一致；

```java
public ByteBuffer duplicate() {
    return new HeapByteBuffer(hb,
                                    this.markValue(),
                                    this.position(),
                                    this.limit(),
                                    this.capacity(),
                                    offset);
}
```

10. `get`：读取数据

```java
    public byte get() {
        return hb[ix(nextGetIndex())];
    }

    public byte get(int i) {
        return hb[ix(checkIndex(i))];
    }

    public ByteBuffer get(byte[] dst, int offset, int length) {
        checkBounds(offset, length, dst.length);
        if (length > remaining())
            throw new BufferUnderflowException();
        System.arraycopy(hb, ix(position()), dst, offset, length);
        position(position() + length);
        return this;
    }

```

11. `put`：写入数据

```java
    public ByteBuffer put(byte x) {
        hb[ix(nextPutIndex())] = x;
        return this;
    }

    public ByteBuffer put(int i, byte x) {
        hb[ix(checkIndex(i))] = x;
        return this;
    }

    public ByteBuffer put(byte[] src, int offset, int length) {
        checkBounds(offset, length, src.length);
        if (length > remaining())
            throw new BufferOverflowException();
        System.arraycopy(src, offset, hb, ix(position()), length);
        position(position() + length);
        return this;
    }

    public ByteBuffer put(ByteBuffer src) {
        if (src instanceof HeapByteBuffer) {
            if (src == this)
                throw new IllegalArgumentException();
            HeapByteBuffer sb = (HeapByteBuffer)src;
            int spos = sb.position();
            int pos = position();
            int n = sb.remaining();
            if (n > remaining())
                throw new BufferOverflowException();
            System.arraycopy(sb.hb, sb.ix(spos),
                             hb, ix(pos), n);
            sb.position(spos + n);
            position(pos + n);
        } else if (src.isDirect()) {
            int n = src.remaining();
            if (n > remaining())
                throw new BufferOverflowException();
            src.get(hb, ix(position()), n);
            position(position() + n);
        } else {
            super.put(src);
        }
        return this;
    }

```

## ByteBuf

### 属性

1. `readerIndex`：可读下标，不能超过`writerIndex`
2. `writerIndex`：可写下标
3. `markedReaderIndex`：标记的读下标
4. `markedWriterIndex`：标记的写下标
5. `maxCapacity`：最大容量


### 常用方法

以`UnpooledHeapByteBuf`为示例，其包含一些属性：

```java
    private final ByteBufAllocator alloc;
    byte[] array;
    private ByteBuffer tmpNioBuf;
```

下面是一些常见的方法：

1. `discardReadBytes`：丢弃已读字节

```java

    public ByteBuf discardReadBytes() {
        if (readerIndex == 0) {
            ensureAccessible();
            return this;
        }

        if (readerIndex != writerIndex) {
            setBytes(0, this, readerIndex, writerIndex - readerIndex);
            writerIndex -= readerIndex;
            adjustMarkers(readerIndex);
            readerIndex = 0;
        } else {
            ensureAccessible();
            adjustMarkers(readerIndex);
            writerIndex = readerIndex = 0;
        }
        return this;
    }
```

2. `slice`：切片

```java
    public ByteBuf slice(int index, int length) {
        ensureAccessible();
        return new UnpooledSlicedByteBuf(this, index, length);
    }
```

3. `capacity`：当前容量

```java
    public int capacity() {
        return array.length;
    }
```

4. `capacity`：扩容

```java
    public ByteBuf capacity(int newCapacity) {
        checkNewCapacity(newCapacity);
        byte[] oldArray = array;
        int oldCapacity = oldArray.length;
        if (newCapacity == oldCapacity) {
            return this;
        }

        int bytesToCopy;
        if (newCapacity > oldCapacity) {
            bytesToCopy = oldCapacity;
        } else {
            trimIndicesToCapacity(newCapacity);
            bytesToCopy = newCapacity;
        }
        byte[] newArray = allocateArray(newCapacity);
        System.arraycopy(oldArray, 0, newArray, 0, bytesToCopy);
        setArray(newArray);
        freeArray(oldArray);
        return this;
    }
```

### 常用辅助类

#### CompositeByteBuf

CompositeByteBuf是Netty用于处理多份数据的利器，它的实用是在于其可组装多个ByteBuf，形成一个统一的访问入口。例如我们在解析HTTP协议时，常常我们会分为两部分来解析：1. 请求头；2. 消息体，这种情况下使用CompositeByteBuf来处理数据会非常方便。

```java
String a = "ccc";
String b = "dddd";
ByteBuf buf1 = Unpooled.wrappedBuffer(a.getBytes(CharsetUtil.UTF_8));
ByteBuf buf2 = Unpooled.wrappedBuffer(b.getBytes(CharsetUtil.UTF_8));
ByteBuf compositeByteBuf = Unpooled.wrappedBuffer(buf1,buf2);

int size = compositeByteBuf.readableBytes();
byte[] bytes = new byte[size];
compositeByteBuf.readBytes(bytes);
String value = new String(bytes,CharsetUtil.UTF_8);
System.out.println("composite buff result : " + value);
```

#### ByteBufHolder

好用的ByteBuf容器，对ByteBuf进行包装和抽象，以满足一些定制化的需求

#### ByteBufAllocator

ByteBufAllocator是ByteBuf的分配器，负责创建ByteBuf

#### Unpooled

该工具类提供简便的静态方法来创建`ByteBuf`，其内部维护了一个默认的`ByteBufAllocator`，用于创建`ByteBuf`

```java
// Unpooled内部的分配器
private static final ByteBufAllocator ALLOC = UnpooledByteBufAllocator.DEFAULT;

// UnpooledByteBufAllocator的静态变量
public static final UnpooledByteBufAllocator DEFAULT =
            new UnpooledByteBufAllocator(PlatformDependent.directBufferPreferred());
```

1. `buffer`：创建一个`Heap`的`ByteBuf`
```java
    public static ByteBuf buffer() {
        return ALLOC.heapBuffer();
    }

    public static ByteBuf buffer(int initialCapacity) {
        return ALLOC.heapBuffer(initialCapacity);
    }

    public static ByteBuf buffer(int initialCapacity, int maxCapacity) {
        return ALLOC.heapBuffer(initialCapacity, maxCapacity);
    }
```

2. `directBuffer`：创建一个直接内存的`ByteBuf`
```java
    public static ByteBuf directBuffer() {
        return ALLOC.directBuffer();
    }

    public static ByteBuf directBuffer(int initialCapacity) {
        return ALLOC.directBuffer(initialCapacity);
    }

    public static ByteBuf directBuffer(int initialCapacity, int maxCapacity) {
        return ALLOC.directBuffer(initialCapacity, maxCapacity);
    }
```

3. `wrappedBuffer`：将入参包装成`ByteBuf`。在多个容器的情况下，会创建一个`CompositeByteBuf`
```java
    public static ByteBuf wrappedBuffer(byte[] array) {
        if (array.length == 0) {
            return EMPTY_BUFFER;
        }
        return new UnpooledHeapByteBuf(ALLOC, array, array.length);
    }

    public static ByteBuf wrappedBuffer(ByteBuffer buffer) {
        if (!buffer.hasRemaining()) {
            return EMPTY_BUFFER;
        }
        if (!buffer.isDirect() && buffer.hasArray()) {
            return wrappedBuffer(
                    buffer.array(),
                    buffer.arrayOffset() + buffer.position(),
                    buffer.remaining()).order(buffer.order());
        } else if (PlatformDependent.hasUnsafe()) {
            if (buffer.isReadOnly()) {
                if (buffer.isDirect()) {
                    return new ReadOnlyUnsafeDirectByteBuf(ALLOC, buffer);
                } else {
                    return new ReadOnlyByteBufferBuf(ALLOC, buffer);
                }
            } else {
                return new UnpooledUnsafeDirectByteBuf(ALLOC, buffer, buffer.remaining());
            }
        } else {
            if (buffer.isReadOnly()) {
                return new ReadOnlyByteBufferBuf(ALLOC, buffer);
            }  else {
                return new UnpooledDirectByteBuf(ALLOC, buffer, buffer.remaining());
            }
        }
    }

    static <T> ByteBuf wrappedBuffer(int maxNumComponents, ByteWrapper<T> wrapper, T[] array) {
        switch (array.length) {
        case 0:
            break;
        case 1:
            if (!wrapper.isEmpty(array[0])) {
                return wrapper.wrap(array[0]);
            }
            break;
        default:
            for (int i = 0, len = array.length; i < len; i++) {
                T bytes = array[i];
                if (bytes == null) {
                    return EMPTY_BUFFER;
                }
                if (!wrapper.isEmpty(bytes)) {
                    return new CompositeByteBuf(ALLOC, false, maxNumComponents, wrapper, array, i);
                }
            }
        }

        return EMPTY_BUFFER;
    }

    public static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuf... buffers) {
        switch (buffers.length) {
        case 0:
            break;
        case 1:
            ByteBuf buffer = buffers[0];
            if (buffer.isReadable()) {
                return wrappedBuffer(buffer.order(BIG_ENDIAN));
            } else {
                buffer.release();
            }
            break;
        default:
            for (int i = 0; i < buffers.length; i++) {
                ByteBuf buf = buffers[i];
                if (buf.isReadable()) {
                    return new CompositeByteBuf(ALLOC, false, maxNumComponents, buffers, i);
                }
                buf.release();
            }
            break;
        }
        return EMPTY_BUFFER;
    }
```

4. `compositeBuffer`：创建一个空`CompositeByteBuf`，`components`最大容量为16
```java
    public static CompositeByteBuf compositeBuffer() {
        return compositeBuffer(AbstractByteBufAllocator.DEFAULT_MAX_COMPONENTS);
    }
```

5. `copiedBuffer`：复制入参，并生成新的`ByteBuf`
```java
    public static ByteBuf copiedBuffer(byte[] array) {
        if (array.length == 0) {
            return EMPTY_BUFFER;
        }
        return wrappedBuffer(array.clone());
    }

    public static ByteBuf copiedBuffer(ByteBuffer buffer) {
        int length = buffer.remaining();
        if (length == 0) {
            return EMPTY_BUFFER;
        }
        byte[] copy = PlatformDependent.allocateUninitializedArray(length);
        // Duplicate the buffer so we not adjust the position during our get operation.
        // See https://github.com/netty/netty/issues/3896
        ByteBuffer duplicate = buffer.duplicate();
        duplicate.get(copy);
        return wrappedBuffer(copy).order(duplicate.order());
    }
```

#### ByteBufUtil

1. `hexDump`：将容器内的数据转换为十六进制

```java
    public static String hexDump(ByteBuf buffer) {
        return hexDump(buffer, buffer.readerIndex(), buffer.readableBytes());
    }

    public static String hexDump(ByteBuf buffer, int fromIndex, int length) {
        return HexUtil.hexDump(buffer, fromIndex, length);
    }
```

2. `decodeHexDump`：将十六进制字符串转换为字节数组

```java
    public static byte[] decodeHexDump(CharSequence hexDump) {
        return StringUtil.decodeHexDump(hexDump, 0, hexDump.length());
    }

    public static byte[] decodeHexDump(CharSequence hexDump, int fromIndex, int length) {
        return StringUtil.decodeHexDump(hexDump, fromIndex, length);
    }
```

3. `hashCode`：计算ByteBuf的hash值

```java
    public static byte[] decodeHexDump(CharSequence hexDump) {
        return StringUtil.decodeHexDump(hexDump, 0, hexDump.length());
    }

    public static byte[] decodeHexDump(CharSequence hexDump, int fromIndex, int length) {
        return StringUtil.decodeHexDump(hexDump, fromIndex, length);
    }
```

4. `equals`：用于判断两个ByteBuf是否相等

```java
    public static boolean equals(ByteBuf bufferA, ByteBuf bufferB) {
        if (bufferA == bufferB) {
            return true;
        }
        final int aLen = bufferA.readableBytes();
        if (aLen != bufferB.readableBytes()) {
            return false;
        }
        return equals(bufferA, bufferA.readerIndex(), bufferB, bufferB.readerIndex(), aLen);
    }

    public static boolean equals(ByteBuf a, int aStartIndex, ByteBuf b, int bStartIndex, int length) {
        checkNotNull(a, "a");
        checkNotNull(b, "b");
        // All indexes and lengths must be non-negative
        checkPositiveOrZero(aStartIndex, "aStartIndex");
        checkPositiveOrZero(bStartIndex, "bStartIndex");
        checkPositiveOrZero(length, "length");

        if (a.writerIndex() - length < aStartIndex || b.writerIndex() - length < bStartIndex) {
            return false;
        }

        final int longCount = length >>> 3;
        final int byteCount = length & 7;

        if (a.order() == b.order()) {
            for (int i = longCount; i > 0; i --) {
                if (a.getLong(aStartIndex) != b.getLong(bStartIndex)) {
                    return false;
                }
                aStartIndex += 8;
                bStartIndex += 8;
            }
        } else {
            for (int i = longCount; i > 0; i --) {
                if (a.getLong(aStartIndex) != swapLong(b.getLong(bStartIndex))) {
                    return false;
                }
                aStartIndex += 8;
                bStartIndex += 8;
            }
        }

        for (int i = byteCount; i > 0; i --) {
            if (a.getByte(aStartIndex) != b.getByte(bStartIndex)) {
                return false;
            }
            aStartIndex ++;
            bStartIndex ++;
        }

        return true;
    }
```

5. indexOf
6. lastIndexOf

等等，当然还有一些其他实用的便捷方法，此处不再细述


## 总结

ByteBuf相较于ByteBuffer更加强大，而且netty扩充了非常多的工具类来帮助我们更方便的使用。