# ByteBuf与ByteBuffer

`ByteBuf`是`netty`用来处理字节数据的缓冲接口，较之`ByteBuffer`，拥有更便捷的方法来处理数据读写

## ByteBuffer

在学习`ByteBuf`之前，我们先要熟悉下JDK自带的缓冲器`ByteBuffer`

### 属性

1. `mark`：用于标记，使用`mark()`方法时，可将当前`position`赋值给`mark`；通过`markValue()`获取值。
2. `position`：指向当前读/写的下标；`position()`获取当前下标
3. `limit`：限制读写；`limit()`方法获取值
4. `capacity`：容器总容量；`capacity()`方法获取值


### 常用方法

1. `flip`：切换读写
```java
    public final Buffer flip() {
        limit = position;
        position = 0;
        mark = -1;
        return this;
    }
```

2. `clear`：清空数据
```java
    public final Buffer clear() {
        position = 0;
        limit = capacity;
        mark = -1;
        return this;
    }
```

3. `reset`：回到标记点
```java
    public final Buffer reset() {
        int m = mark;
        if (m < 0)
            throw new InvalidMarkException();
        position = m;
        return this;
    }
```

4. `rewind`：重置`position`，`mark`值
```java
    public final Buffer rewind() {
        position = 0;
        mark = -1;
        return this;
    }
```

5. `remaining`：剩余可操作空间
```java
    public final int remaining() {
        int rem = limit - position;
        return rem > 0 ? rem : 0;
    }
```

6. `nextGetIndex`：下一个读的下标
```java
    final int nextGetIndex() {                          // package-private
        int p = position;
        if (p >= limit)
            throw new BufferUnderflowException();
        position = p + 1;
        return p;
    }
```

7. `nextPutIndex`：下一个写的下标
```java
    final int nextPutIndex() {                          // package-private
        int p = position;
        if (p >= limit)
            throw new BufferOverflowException();
        position = p + 1;
        return p;
    }
```

## AbstractByteBuf

### 属性

1. readerIndex：可读下标
2. writerIndex：可写下标
3. markedReaderIndex：标记的读下标
4. markedWriterIndex：标记的写下标
5. maxCapacity：最大容量

### 方法