# Pipeline

pipeline在netty中，作用非凡，所有inbound，outbound事件均是通过pipeline来完成的。在pipeline中维护了一条执行器链(双向链表)，处理所有的inbound，outbound事件。该链表由一个固定头节点（HeadContext）以及一个固定尾节点（TailContext）组成，所有新增的节点都在该两节点之间。

## 一、添加处理器

添加处理器的过程都差不多，所以就以addLast为例来分析添加过程：
1. 检查handler是否可以重复使用
2. 新增HandlerContext来维系执行器链
3. 处理链表添加逻辑
4. 如果channel还未注册，则将状态设置为待添加，并创建相应任务，在channel注册成功后，再将状态转换为已添加
5. 如果是channel已注册，则判断当前线程是否处于EventExecutor的线程中，是的话，则直接执行将HandlerContext设置为已添加，不是的话，就以任务的方式，放到EventExecutor的任务队列中执行

```java
public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) {
    final AbstractChannelHandlerContext newCtx;
    synchronized (this) {
        checkMultiplicity(handler);

        newCtx = newContext(group, filterName(name, handler), handler);

        addLast0(newCtx);

        // If the registered is false it means that the channel was not registered on an eventLoop yet.
        // In this case we add the context to the pipeline and add a task that will call
        // ChannelHandler.handlerAdded(...) once the channel is registered.
        if (!registered) {
            newCtx.setAddPending();
            callHandlerCallbackLater(newCtx, true);
            return this;
        }

        EventExecutor executor = newCtx.executor();
        if (!executor.inEventLoop()) {
            callHandlerAddedInEventLoop(newCtx, executor);
            return this;
        }
    }
    callHandlerAdded0(newCtx);
    return this;
}
```

## 二、ChannelHandlerContext

默认使用的是

在pipeline中的执行器链，并不是直接使用ChannelHandler组成，而是通过ChannelHandlerContext的next，prev属性来维护链表，当然ChannelHandlerContext的作用也不止于此：
1. 每个Handler都有一个handlerState来标识handler的状态（INIT/ADD_PENDING/ADD_COMPLETE/REMOVE_COMPLETE）
2. 执行器EventExecutor：该handler的所有动作都将由EventExecutor来执行
3. pipeline的引用
4. executionMask：用于标识该handler感兴趣的inbound，outbound事件
5. succeededFuture：通常用于表示一个异步操作已经完成且成功，不需要再进行额外的处理。

### 2.1 执行器状态

|状态|值|状态描述|具体作用|
|:---|:--:|:---|:---|
|INIT|0|初始状态|HandlerContext未加入pipeline时的初始状态|
|ADD_PENDING|1|待添加|如果channel在还未注册，HandlerContext加入pipeline时的状态会被设置成待添加，等到channel注册成功后，在HeadContext中处理channelRegistered事件时，将状态转换为ADD_COMPLETE|
|ADD_COMPLETE|2|已添加|如果channel注册成功话，在HandlerContext添加到pipeline时，状态就是已添加；另一种情况就是在channelRegistered事件中从待添加转换为已添加|
|REMOVE_COMPLETE|3|已移除|将HandlerContext从pipeline中移除时的状态|

该参数主要的作用是用于判断handler是否可处理事件，只有invokeHandler方法值为true时，该handler方可处理各类事件

```java
// 只有handler处于 已添加状态 或者 无序且状态是待添加 
private boolean invokeHandler() {
    // Store in local variable to reduce volatile reads.
    int handlerState = this.handlerState;
    return handlerState == ADD_COMPLETE || (!ordered && handlerState == ADD_PENDING);
}

@Override
public boolean isRemoved() {
    return handlerState == REMOVE_COMPLETE;
}
```

## 三、HeadContext

HeadContext是整个pipeline中最重要的处理器了，所有inbound，outbound事件，HeadContext都扮演着至关重要的角色

## 四、TailContext