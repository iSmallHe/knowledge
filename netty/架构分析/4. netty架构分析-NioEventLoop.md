# NioEventLoop

    netty的核心模块就在NioEventLoop中，

## 一、diagram

![netty图解](../../image/netty图解.png)

![alt text](../../image/NioeventLoop-extend.png)

## 二、主要属性

|属性|类型|作用|
|:---|:--:|:---|
|selectNowSupplier|IntSupplier|查询连接|
|selector|Selector|JDK的选择器，用于获取连接的建立/读/写/关闭动作|
|unwrappedSelector|Selector|选择器|
|selectedKeys|SelectedSelectionKeySet|本次的连接动作|
|provider|SelectorProvider|选择器|
|nextWakeupNanos|AtomicLong|下一次醒来的时间|
|selectStrategy|SelectStrategy|选择策略|
|ioRatio|int|执行io动作，运行task的时间比例|
|cancelledKeys|int|取消的keys|
|needsToSelectAgain|boolean|是否需要再次查询|

## 三、类加载

```java
// Workaround for JDK NIO bug.
//
// See:
// - https://bugs.openjdk.java.net/browse/JDK-6427854 for first few dev (unreleased) builds of JDK 7
// - https://bugs.openjdk.java.net/browse/JDK-6527572 for JDK prior to 5.0u15-rev and 6u10
// - https://github.com/netty/netty/issues/203
static {
    if (PlatformDependent.javaVersion() < 7) {
        final String key = "sun.nio.ch.bugLevel";
        final String bugLevel = SystemPropertyUtil.get(key);
        if (bugLevel == null) {
            try {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    @Override
                    public Void run() {
                        System.setProperty(key, "");
                        return null;
                    }
                });
            } catch (final SecurityException e) {
                logger.debug("Unable to get/set System Property: " + key, e);
            }
        }
    }

    int selectorAutoRebuildThreshold = SystemPropertyUtil.getInt("io.netty.selectorAutoRebuildThreshold", 512);
    if (selectorAutoRebuildThreshold < MIN_PREMATURE_SELECTOR_RETURNS) {
        selectorAutoRebuildThreshold = 0;
    }

    SELECTOR_AUTO_REBUILD_THRESHOLD = selectorAutoRebuildThreshold;

    if (logger.isDebugEnabled()) {
        logger.debug("-Dio.netty.noKeySetOptimization: {}", DISABLE_KEY_SET_OPTIMIZATION);
        logger.debug("-Dio.netty.selectorAutoRebuildThreshold: {}", SELECTOR_AUTO_REBUILD_THRESHOLD);
    }
}
```

## 四、启动

`NioEventLoop`从类结构上看，他是一个执行器，可执行`Runnable`任务。核心是从`SingleThreadEventExecutor`父类中继承的`execute`方法。

```java
public void execute(Runnable task) {
    execute0(task);
}
private void execute0(@Schedule Runnable task) {
    ObjectUtil.checkNotNull(task, "task");
    execute(task, wakesUpForTask(task));
}
private void execute(Runnable task, boolean immediate) {
    
    boolean inEventLoop = inEventLoop();
    addTask(task);
    if (!inEventLoop) {
        startThread();
        if (isShutdown()) {
            boolean reject = false;
            try {
                if (removeTask(task)) {
                    reject = true;
                }
            } catch (UnsupportedOperationException e) {
                // The task queue does not support removal so the best thing we can do is to just move on and
                // hope we will be able to pick-up the task before its completely terminated.
                // In worst case we will log on termination.
            }
            if (reject) {
                reject();
            }
        }
    }

    if (!addTaskWakesUp && immediate) {
        wakeup(inEventLoop);
    }
}
```

## 五、run
```java
protected void run() {
    for (;;) {
        try {
            switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {
                case SelectStrategy.CONTINUE:
                    continue;
                case SelectStrategy.SELECT:
                    select(wakenUp.getAndSet(false));

                    // 'wakenUp.compareAndSet(false, true)' is always evaluated
                    // before calling 'selector.wakeup()' to reduce the wake-up
                    // overhead. (Selector.wakeup() is an expensive operation.)
                    //
                    // However, there is a race condition in this approach.
                    // The race condition is triggered when 'wakenUp' is set to
                    // true too early.
                    //
                    // 'wakenUp' is set to true too early if:
                    // 1) Selector is waken up between 'wakenUp.set(false)' and
                    //    'selector.select(...)'. (BAD)
                    // 2) Selector is waken up between 'selector.select(...)' and
                    //    'if (wakenUp.get()) { ... }'. (OK)
                    //
                    // In the first case, 'wakenUp' is set to true and the
                    // following 'selector.select(...)' will wake up immediately.
                    // Until 'wakenUp' is set to false again in the next round,
                    // 'wakenUp.compareAndSet(false, true)' will fail, and therefore
                    // any attempt to wake up the Selector will fail, too, causing
                    // the following 'selector.select(...)' call to block
                    // unnecessarily.
                    //
                    // To fix this problem, we wake up the selector again if wakenUp
                    // is true immediately after selector.select(...).
                    // It is inefficient in that it wakes up the selector for both
                    // the first case (BAD - wake-up required) and the second case
                    // (OK - no wake-up required).

                    if (wakenUp.get()) {
                        selector.wakeup();
                    }
                default:
                    // fallthrough
            }

            cancelledKeys = 0;
            needsToSelectAgain = false;
            final int ioRatio = this.ioRatio;
            if (ioRatio == 100) {
                try {
                    processSelectedKeys();
                } finally {
                    // Ensure we always run tasks.
                    runAllTasks();
                }
            } else {
                final long ioStartTime = System.nanoTime();
                try {
                    processSelectedKeys();
                } finally {
                    // Ensure we always run tasks.
                    final long ioTime = System.nanoTime() - ioStartTime;
                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                }
            }
        } catch (Throwable t) {
            handleLoopException(t);
        }
        // Always handle shutdown even if the loop processing threw an exception.
        try {
            if (isShuttingDown()) {
                closeAll();
                if (confirmShutdown()) {
                    return;
                }
            }
        } catch (Throwable t) {
            handleLoopException(t);
        }
    }
}
```

## 六、selector

在 Java NIO 中，`Selector` 提供了 `selectNow()` 和 `select()` 方法来检查注册的 `Channel` 是否有 I/O 事件就绪。它们的主要区别在于 **是否阻塞**。

---

### **1. `selectNow()`**
- **非阻塞**，立即返回。
- 如果没有就绪的通道，返回 `0`。
- 适用于需要轮询检查但不想阻塞的场景。

**示例：**
```java
int readyChannels = selector.selectNow();
if (readyChannels > 0) {
    Set<SelectionKey> selectedKeys = selector.selectedKeys();
    for (SelectionKey key : selectedKeys) {
        // 处理事件
    }
    selectedKeys.clear();
}
```
**特点：**
- 适用于 **主动轮询** 的情况，比如在游戏循环或高频 IO 监测场景中。
- 但如果没有就绪的通道，会浪费 CPU 资源，因为它立即返回，而不是等待事件发生。

---

### **2. `select()`**
- **阻塞**，直到至少有一个通道就绪，或者被其他线程 `wakeup()`，或者被 `close()`。
- 适用于等待 I/O 事件的情况，以提高 CPU 利用率。

**示例：**
```java
int readyChannels = selector.select();
if (readyChannels > 0) {
    Set<SelectionKey> selectedKeys = selector.selectedKeys();
    for (SelectionKey key : selectedKeys) {
        // 处理事件
    }
    selectedKeys.clear();
}
```
**特点：**
- 适用于 **低 CPU 消耗的 I/O 轮询**，因为它会阻塞等待事件发生，而不是空转浪费 CPU。
- 适合需要 **高效等待事件** 的场景，比如服务器处理客户端连接。

---

### **3. `select(timeout)`**
- **带超时时间的 `select`**，在超时时间内如果没有事件就绪，则返回 `0`。
- 适用于既不想一直阻塞等待，也不想浪费 CPU 资源的情况。

**示例：**
```java
int readyChannels = selector.select(5000); // 最多等待 5 秒
```
**特点：**
- 适用于 **定期检查 I/O 但不想无限阻塞** 的场景。

---

### **总结**
| 方法 | 是否阻塞 | 返回值 |
|------|--------|------|
| `selectNow()` | 非阻塞 | 立即返回就绪的通道数，没有就返回 0 |
| `select()` | 阻塞 | 至少有一个通道就绪才返回 |
| `select(timeout)` | 阻塞（带超时） | 在超时内等到至少一个通道就绪，否则返回 0 |

**选择使用场景：**
- **`selectNow()`** → 适合轮询、避免阻塞，但可能浪费 CPU。
- **`select()`** → 适合等待 I/O 事件，提高 CPU 利用率。
- **`select(timeout)`** → 适合折中场景，不想无限等待，也不想过度消耗 CPU。

## 七、task

