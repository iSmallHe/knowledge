# 虚拟机类加载机制
## 1  类加载时机
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止。整个生命周期：加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接。</p>
<img src="../image/类生命周期.png" width="800" height="250"></img>
<p>其中解析阶段并不是按部就班开始的。它在某些情况下可以在初始化阶段之后再开始，这是为了支持java语言的运行时绑定。</p>
<p>什么时候开始第一个阶段：“加载”？虚拟机并没有强制约束，但是对于初始化阶段，虚拟机规范则是严格规定了5种情况必须立即对类进行“初始化”（而加载，验证，准备自然要在之前进行）</p>  

1. 遇到new，getstatic，putstatic，invokestatic这四条指令，将触发初始化。生成这四条指令常见的java场景：
    1. 使用new关键字实例化对象；
    2. 读取或设置一个类的静态字段（被final修饰，已在编译期把结果放入常量池的静态字段除外）；
    3. 调用一个类的静态方法的时候。  
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化过程。
3. 当初始化一个类，发现其父类还没有进行初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，需要一个执行主类，虚拟机会先初始化整个主类。
5. 当使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄，并且整个方法句柄所对应的类没有进行初始化，则需要触发初始化。

## 2  类加载过程
### 2.1  加载
“加载”是类加载过程中的一个阶段，虚拟机需要完成以下三件事：  

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将整个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表整个类的java.lang.Class对象，作为方法区整个类的各种数据的访问入口。
  
### 2.2 验证
确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
1. <font color="#FFA500">文件格式验证</font>
2. <font color="#FFA500">元数据验证</font>
3. <font color="#FFA500">字节码验证</font>
4. <font color="#FFA500">符号引用验证</font>

### 2.3  准备
准备阶段是正式为类变量（static修饰变量）分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。

### 2.4  解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
><font color="#FFA500">**符号引用**</font>：<font color="#43CD80">符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须一致，因为符号引用的字面量形式明确定义在java虚拟机规范的Class文件格式中。</font><br/>

><font color="#FFA500">**直接引用**</font>：<font color="#43CD80">直接引用时可以直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机的内存布局相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</font>
  
1. <font color="#FFA500">类或接口的解析</font>
2. <font color="#FFA500">字段解析</font>
3. <font color="#FFA500">类方法解析</font>
4. <font color="#FFA500">接口方法解析</font>

### 2.5  初始化
初始化阶段是执行类构造器clinit方法的过程。

## 3  类加载器
对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立其在java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗的讲：比较两个类是否相等，只有这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。
### 3.1  双亲委派模型
绝大部分java程序都会使用到以下3中系统提供的类加载器：  

1. <font color="#FFA500">启动类加载器（Bootstrap ClassLoader）</font>：<font color="#43CD80">这个类加载器负责加载<java_home>/lib目录中</font>
2. <font color="#FFA500">扩展类加载器（Extension ClassLoader）</font>：<font color="#43CD80">这个类加载器负责加载<java_home>/lib/ext目录中的</font>
3. <font color="#FFA500">应用程序类加载器（Application ClassLoader）</font>：<font color="#43CD80">它负责加载用户类路径（ClassPath）上的类  </font>
  
<img src="../image/双亲委派.png" width="50%"></img>

<p><font color="#FFA500">双亲委派模式破坏</font>：<font color="#43CD80">线程上下文类加载器（Thread Context ClassLoader），这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</font></p>