# 红黑树

## 特性
红黑树是一种自平衡二叉搜索树，每个节点都有颜色，颜色为红色或黑色，红黑树由此得名。除了满足二叉搜索树的特性以外，红黑树还具有如下特性：

1. 节点是红色或黑色。

2. 根节点是黑色。

3. 所有叶子节点都是黑色的空节点。(叶子节点是NIL节点或NULL节点)

4. 每个红色节点的两个子节点都是黑色节点。(从每个叶子节点到根的所有路径上不能有两个连续的红色节点)

5. 从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。

>这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

## 旋转
### 左旋
    左旋的本质是：将该节点(N)旋转变成左子节点(NL)的右子节点(NLR)，并将原本的右子节点(Pre_NLR)至于该节点(N)的左子节点(NL_Next)

![左旋](../image/left_rotate.png)


### 右旋
    右旋的本质是：将该节点(N)旋转变成右子节点(NR)的左子节点(NRL)，并将原本的左子节点(Pre_NRL)至于该节点(N)的右子节点(NR_Next)

![右旋](../image/right_rotate.png)


## 新增节点

    在红黑树中新增节点的理论操作：在一颗红黑树上插入红节点，最后通过旋转/重新着色使之成为标准意义上的红黑树

**为什么新增的节点都要设置为红节点？**

> 1. 不违背规则5：路径中的黑色节点数量相同
> 2. 根据规则4，表明红黑树中的黑节点个数多于红节点，所以新增节点的父亲节点是黑节点的概率比较大，因为父亲是黑节点的情况下，是不需要做任何处理的，即可满足现有条件。  

**然后我们来看下新节点为红节点情况，在哪些规则下有冲突：**

    规则1：满足
    规则2：满足，如果不满足，也可以修改颜色保证
    规则3：满足
    规则4：可能存在冲突
    规则5：满足

**现在来分析下可能出现的情况及解决措施：**

**情形1. 插入的节点是根节点**

    将节点置为黑色

**情形2. 父节点是黑色**

    无需处理，此时仍满足红黑树的规则

**情形3. 父节点是红色的情况下，其叔叔节点是红色（不分左右）**

    将父节点与叔节点改为黑色，其爷节点置为红色。并且将爷节点当作新插入的红节点，进行各种情况处理

**情形4. 父节点是红色的情况下，其叔叔节点是黑色**

    4.1 父节点是左节点，插入节点是左节点：将爷节点与父节点颜色互换，然后将爷节点右旋
    4.2 父节点是右节点，插入节点是右节点：将爷节点与父节点颜色互换，然后将爷节点左旋
    4.3 父节点是左节点，插入节点是右节点：将父节点左旋，则情况与4.1一致
    4.4 父节点是右节点，插入节点是左节点：将父节点右旋，则情况与4.2一致

### 情形3

**3. 父节点是红色的情况下，其叔叔节点是红色（不分左右）**

    将父节点与叔节点改为黑色，其爷节点置为红色。并且将爷节点当作新插入的红节点，进行各种情况处理

![初始状态](../image/red_black_insert_3.jpg)

    插入红节点125

![插入红节点125](../image/red_black_insert_3_2.jpg)

    交换颜色，爷节点140当作新节点

![交换颜色，爷节点140当作新节点](../image/red_black_insert_3_1.jpg)

    依然是情形3，交换颜色，然后根据情形1再作处理

![依然是当前的情形，交换颜色](../image/red_black_insert_3_3.jpg)

### 情形4
#### 情形4_LL

**4. 父节点是红色的情况下，其叔叔节点是黑色**  
**4.1 父节点是左节点，插入节点是左节点：将爷节点与父节点颜色互换，然后将爷节点右旋**

![初始状态](../image/red_black_insert_ll_1.jpg)

    将爷节点50与父节点30颜色互换，然后将爷节点50右旋

![处理后](../image/red_black_insert_ll_2.jpg)


**如果我们只将颜色互换，不进行旋转，即50成红节点，30成黑节点，是否可行？**

    那么我们稍加分析则可知：此时明显分支 90-60-50-NIL 的黑色节点数量与其他分支的黑色节点数量不一致，违反了规则5

#### 情形4_RR

**4. 父节点是红色的情况下，其叔叔节点是黑色**  
**4.2 父节点是右节点，插入节点是右节点：将爷节点与父节点颜色互换，然后将爷节点左旋**

    该情况与LL型情形差距不大，仅仅只是爷节点左旋的差别，不再赘述

#### 情形4_LR

**4. 父节点是红色的情况下，其叔叔节点是黑色**  
**4.3 父节点是左节点，插入节点是右节点：将父节点左旋，则情况与4.1一致**

![初始状态](../image/red_black_insert_lr_1.jpg)

    将父节点125左旋后，情形与LL型一致

![父节点125左旋](../image/red_black_insert_lr_2.jpg)


#### 情形4_RL

**4. 父节点是红色的情况下，其叔叔节点是黑色**  
**4.4 父节点是右节点，插入节点是左节点：将父节点右旋，则情况与4.2一致**

    该情况与LR型情形差距不大，父节点右旋后，情形与RR型一致

### 总结

    是否插入情形只有上述情况：当然不是

## 删除节点

    删除一个节点，我们要分析哪些规则会遭到破坏，以及如何保证红黑树的正确性：
    
1. 节点是红色或黑色。-- 不会影响

2. 根节点是黑色。-- 影响不大，最后可直接染黑根节点

3. 所有叶子节点都是黑色的空节点。（叶子节点是NIL节点或NULL节点）-- 不会影响

4. 每个红色节点的两个子节点都是黑色节点。（从每个叶子节点到根的所有路径上不能有两个连续的红色节点）-- 易受影响

5. 从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。-- 易受影响

    删除红节点时，影响不大。
    删除黑节点时，容易影响规则4/5。规则4可以重新着色，规则5可以通过借用红节点，即旋转/染色来实现规避

**删除节点需要分别处理几种情况：**
1. 删除节点没有子节点
    1. 删除节点为红色
    2. 删除节点为黑色，其兄弟节点没有子节点
    3. 删除节点为黑色，其兄弟节点只有一个子节点
    4. 删除节点为黑色，其兄弟节点有两个子节点
2. 删除节点只有一个子节点
    1. 删除节点是黑节点，则这个唯一的子节点必然是红节点
    2. 删除节点是红节点，则这个唯一的子节点必然是黑节点（该情况不可能出现，规则4/5不容许）
3. 删除节点有两个子节点

### 删除无子节点

**情形1.1：删除节点没有子节点，且删除节点为红色**

    直接删除该节点，不影响红黑树规则

**情形1.2：删除节点没有子节点，且删除节点为黑色，其兄弟节点没有子节点**

    此时隐含条件：其兄弟节点也是黑节点。但是此时应当再分清父节点颜色：
    1. 父节点红色：这种情况下，可以将兄弟节点染红，父节点染黑，此时删除节点不影响规则5
    2. 父节点黑色：这种情况比较复杂，需要分析


**情形1.3：删除节点没有子节点，且删除节点为黑色，其兄弟节点只有一个子节点**

    1. 如果此时兄弟节点是黑色，则其子节点必然是红色
    2. 如果此时兄弟节点是红色，则其子节点必然是黑色（此时违反了规则5）
    此时的情形1其子节点是否与自己同边即LL/RR，如果是LR/RL，则需要先换色旋转后，转变为LL/RR，来处理。那么此时我们可以将兄弟的子节点染黑，然后将该节点的父节点颜色与兄弟节点交换，然后旋转父节点，即可


**情形1.4：删除节点没有子节点，且删除节点为黑色，其兄弟节点有两个子节点**

    1. 兄弟节点为红色：则两个子节点为黑色：可以将兄弟节点染黑，然后两个子节点染红，即变成下述情况
    2. 兄弟节点为黑色：则两个子节点为红色
    此时删除节点可以将兄弟节点的红子节点借调过来染黑，转换为实际操作：


### 删除单子结点

**情形2.1：删除节点是黑节点，且唯一的子节点必然是红节点**

    这种情况很好处理，即直接删除该节点，并将该节点的子节点染黑代替删除的节点即可。

### 删除双子节点

    这种情况下可以替换为左子节点