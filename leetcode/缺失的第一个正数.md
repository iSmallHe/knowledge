# 缺失的第一个正数

## 题目简述
```
给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
 

示例 1：

输入：nums = [1,2,0]
输出：3
示例 2：

输入：nums = [3,4,-1,1]
输出：2
示例 3：

输入：nums = [7,8,9,11,12]
输出：1
```

## 思路分析

    拿到这个问题时，在不考虑时间复杂度，空间复杂度的情况下，我们最原始直接的方式是：筛选正数，然后排序，寻找第一个缺失的正数
    可是如何排序呢?排序空间复杂度肯定超过O(n)

    这时候我们应当注意题目中的第一个正数，而且我们必须时刻保持灵性的注意到数组下标的妙用。
    示例如下：
    数组：1 3 4 5 9 8 2 6
    下标：0 1 2 3 4 5 6 7
    一个排好序的正数集合，应该是与数组下标形成一个offset=1的关系，这意味着我们只需要将正数放到数组对应下标的位置后，判断下标与值是否满足offset，如果都满足，则意味着值=最大值+1.所以这个问题的核心就变成了：数组中的正数插入到对应位置
    
## 题解

```java
public static int firstMissingPositive(int[] nums) {
    // 处理数组归位，让数字回到对应下标的位置
    int idx = 0;
    int val;
    int nextVal;
    // 外层循环，是用来推动idx，因为有负数，0，内层的while循环无法将所有值移动到合适的位置
    while (idx < nums.length) {
        // 我们这里的思路就是将当前下标的值不满足条件（val != nums[val - 1]），移动到对应位置，就一直往下循环移动
        // 但是要注意一点如果val - 1 == idx，则意味着构成一个回路，此时也应当跳出循环
        nextVal = val = nums[idx];
        while (val > 0 && val <= nums.length && val != nums[val - 1] && val - 1 != idx) {
            nextVal = nums[val - 1];
            nums[val - 1] = val;
            val = nextVal;
        }
        nums[idx] = nextVal;
        idx++;
    }
    // 判断下标与值不合
    for (int i = 0; i < nums.length; i++) {
        if ((i + 1) != nums[i]) {
            return i + 1;
        }
    }
    // 全都符合
    return nums.length + 1;
}
```

## 思考

我们的思路往往被限制在了题目表面上，无法发掘出题目中的深层联系，时常忘记数组下标关系。以后需要加强思考方式，需要字字斟酌来分析题干
