# 一 动态规划
    首先我们需要树立一种思想，一个问题能否不断递归切割成小问题，让这些小问题都能得到初始解时，就意味着我们能使用动态规划来处理该问题。这样听起来，似乎动态规划就是递归，但其实它们的根源都来自于数学的归纳法。不过动态规划还有一个特征就是会存储处理问题过程中每个解，通过小问题与大问题之间的关联关系，得出大问题的解。

# 二 正则匹配

## 2.1 问题
    给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

    '.' 匹配任意单个字符
    '*' 匹配零个或多个前面的那一个元素
    所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

    示例 1：
    输入：s = "aa", p = "a"
    输出：false
    解释："a" 无法匹配 "aa" 整个字符串。

    示例 2:
    输入：s = "aa", p = "a*"
    输出：true
    解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

    示例 3：
    输入：s = "ab", p = ".*"
    输出：true
    解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

**首先我们看到这个问题时，可能直接的思路就是用两路遍历，来进行一一匹配，但这其中包含着各种边界问题处理，导致解决起来异常麻烦，所以我们需要转变思路：首先我们进行正则匹配时，按照正常思路进行判断时，会从起始字符往后遍历，但我们判断的依据源于前置判断的成立，即我们的问题可以不断分解成前置的小问题，进行递推判断**

## 2.2 分析
    分析问题时，我们先假定部分参数：
    字符串S，当前下标i
    规则串P，当前下标j

    1.如果当前s[i] = p[j]时，则当前f(i,j) = f(i-1, j-1)
    2.如果当前s[i] ≠ p[j]时，我们需要判断p[j]是否为特殊字符？
        2.1 p[j] = . 则f(i,j) = f(i-1, j-1)
        2.2 p[j] = * 时，我们需要判定p[j-1]是否为./s[i]
            2.2.1 p[j-1] = . || p[j-1] = s[i] 此时则有三种情况可能满足匹配规则：
                A. f(i,j) = f(i,j-1)    即*号只用来匹配一次
                B. f(i,j) = f(i,j-2)    即*号一次都未匹配
                C. f(i,j) = f(i-1,j)    即*号匹配多次
            2.2.2  p[j-1] = . || p[j-1] = s[i] 都不满足时
                A. f(i,j) = f(i,j-2)    即*号一次都未匹配

## 2.3 编程
```java
/**
    * 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
    *
    * '.' 匹配任意单个字符
    * '*' 匹配零个或多个前面的那一个元素
    * 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
    *
    * @return
    */
public static boolean isMatch(String s, String p) {
    boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
    dp[0][0] = true;
    // 为什么这里要从0开始？
    // 这是因为存在情况"aab", "c*a*b"，即前缀匹配0次
    for (int i = 0; i <= s.length(); i++) {
        for (int j = 1; j <= p.length(); j++) {
            check(i, j, s, p, dp);
        }
    }
    return dp[s.length()][p.length()];
}

public static void check(int i, int j, String s, String p, boolean[][] dp) {
    // "aab", "a*bc*"
    // "aab", "c*a*b"
    // 这里就是用来处理前缀匹配0次的问题
    boolean flag = (i - 1) >= 0;
    // 这里取~，只是拿一个不会存在的字符替代而已
    char sc = flag ? s.charAt(i - 1) : '~';
    char pc = p.charAt(j - 1);
    if (sc == pc) {
        dp[i][j] = dp[i - 1][j - 1];
        return;
    } else {
        if (pc == '.') {
            dp[i][j] = flag && dp[i - 1][j - 1];
            return;
        } else if (pc == '*') {
            char prePc = p.charAt(j - 2);
            if (prePc == '.' || prePc == sc) {
                dp[i][j] = (flag && dp[i - 1][j]) || dp[i][j - 1];
            }
            dp[i][j] = dp[i][j] || dp[i][j - 2];
            return;
        }
    }
    dp[i][j] = false;
}
```